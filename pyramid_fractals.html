<style>
    body {
        margin: 0;
    }

    canvas {
        width: 100vw;
        height: 100vh;
    }

    .bounding-box {
        position: absolute;
        left: 0;
        top: 0;
        width: 0;
        height: 0;
        z-index: 5;
        box-sizing: border-box;
        border: 1px solid black;
        visibility: hidden;
    }
</style>

<canvas></canvas>

<div class="bounding-box"></div>

<script>
    const theGoldenRatio = 1.61803398875

    const devicePixelRatio = window.devicePixelRatio
    const width = window.innerWidth
    const height = window.innerHeight

    let boundingBox
    let scale

    const canvas = document.querySelector('canvas')
    canvas.width = devicePixelRatio * width
    canvas.height = devicePixelRatio * height
    const context = canvas.getContext('2d')
    context.scale(devicePixelRatio, devicePixelRatio)
    context.strokeStyle = 'gold'
    context.fillStyle = 'hsla(51, 100%, 61%, 1)'

    const $boundingBox = document.querySelector('.bounding-box')

    const initialPyramidRadius = 0.125 * Math.min(width, height)

    let pyramids

    setBoundingBox({ x: 0, y: 0, width, height })

    function draw() {
        drawPyramids(pyramids)
    }

    draw()

    window.addEventListener('keydown', (event) => {
        const key = event.key
        if (key === 'ArrowUp') {
            setBoundingBox({ ...boundingBox, y: boundingBox.y + 1 })
            draw()
        } else if (key === 'ArrowRight') {
            setBoundingBox({ ...boundingBox, x: boundingBox.x - 1 })
            draw()
        } else if (key === 'ArrowDown') {
            setBoundingBox({ ...boundingBox, y: boundingBox.y - 1 })
            draw()
        } else if (key === 'ArrowLeft') {
            setBoundingBox({ ...boundingBox, x: boundingBox.x + 1 })
            draw()
        } else if (key === '+') {
            const scaleRatio = 2
            scale *= scaleRatio
            draw()
        } else if (key === '-') {
            const scaleRatio = 0.5
            if (scale * scaleRatio >= 1) {
                scale *= scaleRatio
                draw()
            }
        }
    })

    let fromX, fromY
    window.addEventListener('mousedown', (event) => {
        fromX = event.pageX
        fromY = event.pageY
        $boundingBox.style.width = 0
        $boundingBox.style.height = 0
        $boundingBox.style.visibility = 'visible'
        $boundingBox.style.left = fromX
        $boundingBox.style.top = fromY
    })

    window.addEventListener('mousemove', (event) => {
        let toX = event.pageX
        let toY = event.pageY
        if (toX < fromX) {
            toX = fromX
            fromX = event.pageX
            $boundingBox.style.left = fromX
        }
        if (toY < fromY) {
            toY = fromY
            fromY = event.pageY
            $boundingBox.style.top = fromY
        }
        $boundingBox.style.width = Math.abs(toX - fromX)
        $boundingBox.style.height = Math.abs(toY - fromY)
    })

    window.addEventListener('mouseup', (event) => {
        const toX = event.pageX
        const toY = event.pageY
        $boundingBox.style.right = toX
        $boundingBox.style.bottom = toY
        setBoundingBox({
            x: boundingBox.x + (fromX / window.innerWidth) * boundingBox.width,
            y: boundingBox.y + (fromY / window.innerHeight) * boundingBox.height,
            width: (Math.abs(toX - fromX) / window.innerWidth) * boundingBox.width,
            height: (Math.abs(toY - fromY) / window.innerHeight) * boundingBox.height,
        })
        draw()
        $boundingBox.style.visibility = 'hidden'
    })

    function setBoundingBox(newBoundingBox) {
        boundingBox = newBoundingBox
        scale = Math.max(
            window.innerWidth / boundingBox.width,
            window.innerHeight / boundingBox.height
        )
        console.log(boundingBox, scale)
        context.resetTransform()
        context.clearRect(0, 0, canvas.width, canvas.height)
        context.scale(devicePixelRatio, devicePixelRatio)
        context.save()
        context.fillStyle = 'blue'
        context.beginPath()
        context.rect(
            boundingBox.x - boundingBox.x,
            boundingBox.y - boundingBox.y,
            scale * boundingBox.width,
            scale * boundingBox.height
        )
        context.fill()
        context.restore()

        pyramids = generatePyramidsInBoudingBoxIterative(boundingBox, scale)
    }

    function generatePyramidsRecursiveStart() {
        const pyramidX = 0.5 * (canvas.width / devicePixelRatio)
        const pyramidY = 0.5 * (canvas.height / devicePixelRatio)
        return generatePyramidsRecursive(
            pyramidX,
            pyramidY,
            initialPyramidRadius,
            (3 / 4) * (2 * Math.PI)
        )
    }

    function generatePyramidsRecursive(x, y, radius, angle) {
        const pyramids = []
        pyramids.push(generatePyramid(x, y, radius, angle))
        const nextRadius = radius / theGoldenRatio
        const minRadius = 0.1
        if (devicePixelRatio * nextRadius >= minRadius) {
            if (radius >= initialPyramidRadius) {
                pyramids.push(...generatePyramidsRecursive(
                    x,
                    y - radius - nextRadius,
                    nextRadius,
                    angle + (1 / 2) * (2 * Math.PI)
                ))
            }

            const angle2 = angle + ((1 / 3) * (2 * Math.PI))
            const angle2b = angle2 + ((1 / 2) * (2 * Math.PI))
            pyramids.push(...generatePyramidsRecursive(
                x + ((radius + nextRadius) * Math.cos(angle2)),
                y + ((radius + nextRadius) * Math.sin(angle2)),
                nextRadius,
                angle2b
            ))

            const angle3 = angle2 + ((1 / 3) * (2 * Math.PI))
            const angle3b = angle3 + ((1 / 2) * (2 * Math.PI))
            pyramids.push(...generatePyramidsRecursive(
                x + ((radius + nextRadius) * Math.cos(angle3)),
                y + ((radius + nextRadius) * Math.sin(angle3)),
                nextRadius,
                angle3b
            ))
        }

        return pyramids
    }

    function generatePyramidsIterative() {
        const pyramids = []

        let nextIterationPyramids = [generatePyramid(
            0.5 * (canvas.width / devicePixelRatio),
            0.5 * (canvas.height / devicePixelRatio),
            initialPyramidRadius,
            (3 / 4) * (2 * Math.PI)
        )]
        pyramids.push(...nextIterationPyramids)

        const maxIterations = 8
        let currentIteration = 0

        while (currentIteration < maxIterations && nextIterationPyramids.length >= 1) {
            currentIteration += 1
            const currentIterationPyramids = nextIterationPyramids
            nextIterationPyramids = []

            for (const { x, y, radius, angle } of currentIterationPyramids) {
                const nextRadius = radius / theGoldenRatio
                const minRadius = 0.05
                if (devicePixelRatio * nextRadius >= minRadius) {
                    if (radius >= initialPyramidRadius) {
                        nextIterationPyramids.push(generatePyramid(
                            x,
                            y - radius - nextRadius,
                            nextRadius,
                            angle + (1 / 2) * (2 * Math.PI)
                        ))
                    }

                    const angle2 = angle + ((1 / 3) * (2 * Math.PI))
                    const angle2b = angle2 + ((1 / 2) * (2 * Math.PI))
                    nextIterationPyramids.push(generatePyramid(
                        x + ((radius + nextRadius) * Math.cos(angle2)),
                        y + ((radius + nextRadius) * Math.sin(angle2)),
                        nextRadius,
                        angle2b
                    ))

                    const angle3 = angle2 + ((1 / 3) * (2 * Math.PI))
                    const angle3b = angle3 + ((1 / 2) * (2 * Math.PI))
                    nextIterationPyramids.push(generatePyramid(
                        x + ((radius + nextRadius) * Math.cos(angle3)),
                        y + ((radius + nextRadius) * Math.sin(angle3)),
                        nextRadius,
                        angle3b
                    ))
                }
            }

            pyramids.push(...nextIterationPyramids)
        }

        return pyramids
    }

    function generatePyramidsInBoudingBoxIterative(boundingBox, scale) {
        const pyramids = []

        let nextIterationPyramids = [generatePyramid(
            0.5 * (canvas.width / devicePixelRatio),
            0.5 * (canvas.height / devicePixelRatio),
            initialPyramidRadius,
            (3 / 4) * (2 * Math.PI)
        )]
        pyramids.push(...nextIterationPyramids)

        while (nextIterationPyramids.length >= 1) {
            const currentIterationPyramids = nextIterationPyramids
            nextIterationPyramids = []

            for (const { x, y, radius, angle } of currentIterationPyramids) {
                const coverRadius = 4 * radius
                if (
                    boundingBox.x - coverRadius < x && x < boundingBox.x + boundingBox.width + coverRadius &&
                    boundingBox.y - coverRadius < y && y < boundingBox.y + boundingBox.height + coverRadius
                ) {
                    const nextRadius = radius / theGoldenRatio
                    const minRadius = 3
                    if (scale * devicePixelRatio * nextRadius >= minRadius) {
                        if (radius >= initialPyramidRadius) {
                            nextIterationPyramids.push(generatePyramid(
                                x,
                                y - radius - nextRadius,
                                nextRadius,
                                angle + (1 / 2) * (2 * Math.PI)
                            ))
                        }

                        const angle2 = angle + ((1 / 3) * (2 * Math.PI))
                        const angle2b = angle2 + ((1 / 2) * (2 * Math.PI))
                        nextIterationPyramids.push(generatePyramid(
                            x + ((radius + nextRadius) * Math.cos(angle2)),
                            y + ((radius + nextRadius) * Math.sin(angle2)),
                            nextRadius,
                            angle2b
                        ))

                        const angle3 = angle2 + ((1 / 3) * (2 * Math.PI))
                        const angle3b = angle3 + ((1 / 2) * (2 * Math.PI))
                        nextIterationPyramids.push(generatePyramid(
                            x + ((radius + nextRadius) * Math.cos(angle3)),
                            y + ((radius + nextRadius) * Math.sin(angle3)),
                            nextRadius,
                            angle3b
                        ))
                    }
                }
            }

            pyramids.push(...nextIterationPyramids)
        }

        return pyramids
    }

    function generatePyramid(x, y, radius, angle) {
        return { x, y, radius, angle }
    }

    function drawPyramids(pyramids) {
        for (const pyramid of pyramids) {
            drawPyramid(pyramid)
        }
    }

    function drawPyramid({ x, y, radius, angle }) {
        context.save()
        context.translate(scale * (x - boundingBox.x), scale * (y - boundingBox.y))
        context.rotate(angle - ((3 / 4) * (2 * Math.PI)))
        context.beginPath()
        angle = (3 / 4) * (2 * Math.PI)
        context.lineTo(scale * radius * Math.cos(angle), scale * radius * Math.sin(angle))
        angle += (1 / 3) * (2 * Math.PI)
        context.lineTo(scale * radius * Math.cos(angle), scale * radius * Math.sin(angle))
        angle += (1 / 3) * (2 * Math.PI)
        context.lineTo(scale * radius * Math.cos(angle), scale * radius * Math.sin(angle))
        context.closePath()
        context.fill()
        context.stroke()
        context.restore()

        /*
        context.save()
        context.strokeStyle = 'red'
        context.beginPath()
        context.arc(
            scale * (x - boundingBox.x),
            scale * (y - boundingBox.y),
            scale * 4 * radius,
            0,
            2 * Math.PI
        )
        context.stroke()
        context.restore()
        */
    }
</script>