<style>
  body {
    margin: 0;
    overflow: hidden;
  }

  .pencil {
    border: 1px solid black;
    border-radius: 50%;
    box-sizing: border-box;
    height: 1px;
    pointer-events: none;
    position: absolute;
    width: 1px;
    z-index: 3;
  }
</style>

<div class="pencil"></div>
<canvas></canvas>

<script type="module">
  import { detectCorners } from './detectCorners.js'

  const pencil = document.querySelector('.pencil')
  const canvas = document.querySelector('canvas')
  canvas.style.width = window.innerWidth
  canvas.style.height = window.innerHeight
  canvas.width = window.devicePixelRatio * window.innerWidth
  canvas.height = window.devicePixelRatio * window.innerHeight
  const context = canvas.getContext('2d')
  context.lineWidth = 1
  context.lineCap = 'round'
  context.scale(window.devicePixelRatio, window.devicePixelRatio)

  let isDrawing = false
  let lastPoint
  let points = []
  const figures = []
  window.addEventListener('mousedown', (event) => {
    if (isLeftMouseButton(event)) {
      isDrawing = true
      const point = eventToPoint(event)
      points = []
      points.push(point)
      drawLine(point, point)
      lastPoint = point
    }
  })

  window.addEventListener('mousemove', (event) => {
    const point = eventToPoint(event)
    points.push(point)
    pencil.style.left = point[0]
    pencil.style.top = point[1]
    if (isDrawing) {
      drawLine(lastPoint, point)
      lastPoint = point
    }
  })

  window.addEventListener('mouseup', (event) => {
    isDrawing = false

    // Filter points
    // TODO: Maybe cluster points close together to one centroid point
    let lastPoint = points[0]
    const filteredPoints = [lastPoint]
    for (let index = 1; index < points.length; index++) {
      const point = points[index]
      if (
        point[0] !== lastPoint[0] &&
        point[1] !== lastPoint[1]
      ) {
        filteredPoints.push(point)
        lastPoint = point
      }
    }

    points = filteredPoints

    let cornerPoints = detectCorners(points)
    if (cornerPoints.length < 2) {
      cornerPoints = [points[0], points[points.length - 1]]
    } else if (cornerPoints.length === 4) {
      const a = cornerPoints
      cornerPoints = [
        [
          Math.min(...cornerPoints.map(p => p[0])),
          Math.min(...cornerPoints.map(p => p[1])),
        ],
        [
          Math.max(...cornerPoints.map(p => p[0])),
          Math.min(...cornerPoints.map(p => p[1])),
        ],
        [
          Math.max(...cornerPoints.map(p => p[0])),
          Math.max(...cornerPoints.map(p => p[1])),
        ],
        [
          Math.min(...cornerPoints.map(p => p[0])),
          Math.max(...cornerPoints.map(p => p[1])),
        ],
      ]
    }

    console.log('cornerPoints', cornerPoints)

    const figure = {
      type: 'polygon',
      cornerPoints,
    }
    figures.push(figure)

    context.clearRect(
      0,
      0,
      canvas.width / window.devicePixelRatio,
      canvas.height / window.devicePixelRatio,
    )
    for (const figure of figures) {
      if (figure.type === 'polygon') {
        drawPolygon(figure.cornerPoints)
      } else {
        console.error(`Drawing figure of type "${figure.type}" not implemented.`)
      }
    }

    /*
    context.save()
    context.fillStyle = 'red'
    drawPoints(points, 3)
    context.restore()
    */

    context.save()
    context.fillStyle = 'blue'
    drawPoints(cornerPoints, 3)
    context.restore()

    points = []
  })

  window.addEventListener('wheel', (event) => {
    const deltaY = event.deltaY
    if (deltaY !== 0) {
      if (deltaY < 0) {
        context.lineWidth *= 2
      } else if (deltaY > 0) {
        context.lineWidth = Math.max(1, context.lineWidth / 2)
      }
      const pencilRadius = 0.5 * context.lineWidth
      pencil.style.width = 2 * pencilRadius
      pencil.style.height = 2 * pencilRadius
      pencil.style.marginLeft = -pencilRadius
      pencil.style.marginTop = -pencilRadius
    }
  })

  window.addEventListener('resize', throttle(() => {
    const oldWidth = parseInt(canvas.style.width, 10)
    const newWidth = window.innerWidth
    const oldHeight = parseInt(canvas.style.height, 10)
    const newHeight = window.innerHeight

    if (newWidth > oldWidth || newHeight > oldHeight) {
      const copyCanvas = document.createElement('canvas')
      copyCanvas.width = canvas.width
      copyCanvas.height = canvas.height
      const copyContext = copyCanvas.getContext('2d')
      copyContext.putImageData(
        context.getImageData(0, 0, canvas.width, canvas.height),
        0,
        0,
      )

      if (newWidth > oldWidth) {
        canvas.style.width = newWidth
        canvas.width = window.devicePixelRatio * newWidth
      }

      if (newHeight > oldHeight) {
        canvas.style.height = newHeight
        canvas.height = window.devicePixelRatio * newHeight
      }

      context.resetTransform()
      context.scale(window.devicePixelRatio, window.devicePixelRatio)
      context.putImageData(copyContext.getImageData(
        0,
        0,
        copyCanvas.width,
        copyCanvas.height,
      ), 0, 0)
      copyCanvas.remove()
    }
  }, 200))

  function throttle (fn, delay) {
    let handle
    return (...args) => {
      if (handle) {
        clearTimeout(handle)
      }
      handle = setTimeout(() => {
        fn(...args)
        handle = null
      }, delay)
    }
  }

  function isLeftMouseButton (event) {
    return event.button === 0
  }

  function eventToPoint (event) {
    return [event.pageX, event.pageY]
  }

  function drawLine (a, b) {
    context.beginPath()
    context.moveTo(a[0], a[1])
    context.lineTo(b[0], b[1])
    context.stroke()
  }

  function drawPolygon (points) {
    context.beginPath()
    const firstPoint = points[0]
    context.moveTo(firstPoint[0], firstPoint[1])
    for (let index = 1; index < points.length; index++) {
      const point = points[index]
      const [x, y] = point
      context.lineTo(x, y)
    }
    context.closePath()
    context.stroke()
  }

  function drawPoints (points, radius = 1) {
    for (const point of points) {
      context.fillRect(
        point[0] - 0.5 * (radius - 1),
        point[1] - 0.5 * (radius - 1),
        radius,
        radius,
      )
    }
  }

  function slope (pointA, pointB) {
    return (
        pointB[1] - pointA[1]
      ) /
      (
        pointB[0] - pointA[0]
      )
  }

  function radianToDegree (value) {
    return value *
      (
        2 * Math.PI
      )
  }
</script>
