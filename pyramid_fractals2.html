<style>
    body {
        margin: 0;
    }

    canvas {
        width: 100vw;
        height: 100vh;
    }
</style>

<canvas></canvas>

<script>
    // Infinite zoom animation

    const devicePixelRatio = window.devicePixelRatio
    const width = window.innerWidth
    const height = window.innerHeight

    let boundingBox
    let scale

    const canvas = document.querySelector('canvas')
    canvas.width = devicePixelRatio * width
    canvas.height = devicePixelRatio * height
    const context = canvas.getContext('2d')
    context.scale(devicePixelRatio, devicePixelRatio)
    context.lineWidth = 1
    context.strokeStyle = 'black'
    context.fillStyle = 'hsla(51, 100%, 61%, 1)'

    const initialPyramidRadius = 0.5 * 0.9 * Math.min(width, height)

    let pyramids

    setBoundingBox({x: 0, y: 0, width, height})

    draw()

    function setBoundingBox(newBoundingBox) {
        boundingBox = newBoundingBox
        scale = Math.max(
            window.innerWidth / boundingBox.width,
            window.innerHeight / boundingBox.height
        )
        console.log(boundingBox, scale)
        context.resetTransform()
        context.clearRect(0, 0, canvas.width, canvas.height)
        context.scale(devicePixelRatio, devicePixelRatio)
        context.save()
        context.fillStyle = 'blue'
        context.beginPath()
        context.rect(
            boundingBox.x - boundingBox.x,
            boundingBox.y - boundingBox.y,
            scale * boundingBox.width,
            scale * boundingBox.height
        )
        context.fill()
        context.restore()

        pyramids = generatePyramidsInBoudingBoxIterative(boundingBox, scale)
    }

    function generatePyramidsInBoudingBoxIterative(boundingBox, scale) {
        const pyramids = []

        let nextIterationPyramids = [generatePyramid(
            0.5 * (canvas.width / devicePixelRatio),
            0.5 * (canvas.height / devicePixelRatio),
            initialPyramidRadius,
            (3 / 4) * (2 * Math.PI)  // + (1 / 2) * (2 * Math.PI)
        )]
        pyramids.push(...nextIterationPyramids)

        while (nextIterationPyramids.length >= 1) {
            const currentIterationPyramids = nextIterationPyramids
            nextIterationPyramids = []

            for (const {x, y, radius, angle} of currentIterationPyramids) {
                const nextRadius = radius / 2
                const minRadius = 10
                if (scale * devicePixelRatio * nextRadius >= minRadius) {
                    if (angle % (2 * Math.PI) === (3 / 4) * (2 * Math.PI)) {
                        nextIterationPyramids.push(generatePyramid(
                            x,
                            y - nextRadius,
                            nextRadius,
                            angle
                        ))

                        nextIterationPyramids.push(generatePyramid(
                            x + nextRadius * Math.cos(angle - (1 / 3) * (2 * Math.PI)),
                            y + nextRadius * Math.sin(angle - (1 / 3) * (2 * Math.PI)),
                            nextRadius,
                            angle
                        ))

                        nextIterationPyramids.push(generatePyramid(
                            x,
                            y,
                            nextRadius,
                            angle + ((1 / 2) * (2 * Math.PI))
                        ))

                        nextIterationPyramids.push(generatePyramid(
                            x + nextRadius * Math.cos(angle - (2 / 3) * (2 * Math.PI)),
                            y + nextRadius * Math.sin(angle - (2 / 3) * (2 * Math.PI)),
                            nextRadius,
                            angle
                        ))
                    } else {
                        nextIterationPyramids.push(generatePyramid(
                            x + nextRadius * Math.cos(angle + (1 / 3) * (2 * Math.PI)),
                            y + nextRadius * Math.sin(angle + (1 / 3) * (2 * Math.PI)),
                            nextRadius,
                            angle
                        ))

                        nextIterationPyramids.push(generatePyramid(
                            x,
                            y,
                            nextRadius,
                            angle + ((1 / 2) * (2 * Math.PI))
                        ))

                        nextIterationPyramids.push(generatePyramid(
                            x + nextRadius * Math.cos(angle + (2 / 3) * (2 * Math.PI)),
                            y + nextRadius * Math.sin(angle + (2 / 3) * (2 * Math.PI)),
                            nextRadius,
                            angle
                        ))

                        nextIterationPyramids.push(generatePyramid(
                            x,
                            y + nextRadius,
                            nextRadius,
                            angle
                        ))
                    }
                }
            }

            pyramids.push(...nextIterationPyramids)
            // return pyramids
        }

        return pyramids
    }

    function generatePyramid(x, y, radius, angle) {
        return {x, y, radius, angle}
    }

    function draw() {
        drawPyramids(pyramids)
    }

    function drawPyramids(pyramids) {
        for (const pyramid of pyramids) {
            drawPyramid(pyramid)
        }
    }

    function drawPyramid({x, y, radius, angle}) {
        context.save()        
        context.translate(scale * (x - boundingBox.x), scale * (y - boundingBox.y))
        context.rotate(angle - ((3 / 4) * (2 * Math.PI)))
        context.beginPath()
        angle = (3 / 4) * (2 * Math.PI) 
        context.lineTo(scale * radius * Math.cos(angle), scale * radius * Math.sin(angle))
        angle += (1 / 3) * (2 * Math.PI)
        context.lineTo(scale * radius * Math.cos(angle), scale * radius * Math.sin(angle))
        angle += (1 / 3) * (2 * Math.PI)
        context.lineTo(scale * radius * Math.cos(angle), scale * radius * Math.sin(angle))
        context.closePath()
        context.fill()
        context.stroke()
        context.restore()

        /*
        context.save()
        context.lineWidth = 1
        context.strokeStyle = 'red'
        context.fillStyle = 'red'

        context.fillRect(
            scale * (x - boundingBox.x),
            scale * (y - boundingBox.y),
            1,
            1
        )

        context.beginPath()
        context.arc(
            scale * (x - boundingBox.x),
            scale * (y - boundingBox.y),
            scale * radius,
            0,
            2 * Math.PI
        )
        context.stroke()
        context.restore()
        */
    }
</script>