{"version":3,"file":"index.js","mappings":"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","sources":["webpack:///./node_modules/lodash.debounce/index.js","webpack:///webpack/bootstrap","webpack:///webpack/runtime/compat get default export","webpack:///webpack/runtime/define property getters","webpack:///webpack/runtime/global","webpack:///webpack/runtime/hasOwnProperty shorthand","webpack:///./src/index.js","webpack:///../selectRandomUniform.js","webpack:///../randomInteger.js"],"sourcesContent":["/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/** Used to match leading and trailing whitespace. */\nvar reTrim = /^\\s+|\\s+$/g;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        result = wait - timeSinceLastCall;\n\n    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = value.replace(reTrim, '');\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nmodule.exports = debounce;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import { selectRandomUniform } from '../../selectRandomUniform.js'\nimport debounce from 'lodash.debounce'\n\nconst CIRCLE_MARGIN = 4 // 0.25rem with 1rem = 16px\nconst SPACE_BETWEEN_CIRCLES = 2 * CIRCLE_MARGIN\nconst CIRCLE_LENGTH = 32 // 2rem with 1rem = 16px\nconst CIRCLE_WIDTH = CIRCLE_LENGTH\nconst CIRCLE_HEIGHT = CIRCLE_LENGTH\nconst CIRCLE_BORDER = 1 // px\nconst MAXIMUM_MOVE_DISTANCE = CIRCLE_LENGTH + 2 * CIRCLE_BORDER + SPACE_BETWEEN_CIRCLES\nconst DISTANCE_THRESHOLD = 0.5 * (CIRCLE_LENGTH + 2 * CIRCLE_BORDER + SPACE_BETWEEN_CIRCLES) // px\nconst MINIMUM_AMOUNT_OF_CIRCLES_ON_SAME_LINE_FOR_REMOVAL = 3\nconst ANIMATION_DURATION = 400\n\nexport function main() {\n  const numberOfRows = 20\n  const numberOfColumns = 20\n  const colors = ['red', 'green', 'yellow', 'blue']\n  const circleGrid = document.querySelector('.circle-grid')\n  spawnCircles(circleGrid, { rows: numberOfRows, columns: numberOfColumns, colors })\n\n  const connectionLineCanvas = document.querySelector('.connection-line-canvas')\n  connectionLineCanvas.width = circleGrid.clientWidth\n  connectionLineCanvas.height = circleGrid.clientHeight\n  const context = connectionLineCanvas.getContext('2d')\n\n  let selectedCircles = new Set()\n  let firstSelectedCircle = null\n  let selectedColor = null\n  let lastSelectedCircle = null\n  let selectedCircleOffset = null\n  let lastCircleThatTheSelectedCircleWasMovingTowards = null\n\n  function isSelectingCircles() {\n    return lastSelectedCircle !== null\n  }\n\n  circleGrid.addEventListener('pointerdown', function (event) {\n    const target = event.target\n    if (target.classList.contains('circle')) {\n      event.preventDefault()\n      const circle = target\n      selectedCircles.add(circle)\n      firstSelectedCircle = circle\n      selectedColor = determineCircleColor(firstSelectedCircle)\n      lastSelectedCircle = circle\n      selectedCircleOffset = {\n        x: 0,\n        y: 0,\n      }\n      firstSelectedCircle.classList.add('circle--dragged')\n      updateCircleOffsets()\n    }\n  })\n\n  circleGrid.addEventListener('pointermove', function (event) {\n    if (isSelectingCircles()) {\n      const target = event.target\n      if (target.classList.contains('circle')) {\n        const circle = target\n        const circleColor = determineCircleColor(circle)\n        if (\n          circleColor === selectedColor &&\n          (!selectedCircles.has(circle) || (selectedCircles.size >= 3 && circle === firstSelectedCircle)) &&\n          canBeConnected(circle, lastSelectedCircle)\n        ) {\n          drawConnectionLine(circle, lastSelectedCircle)\n          selectedCircles.add(circle)\n          lastSelectedCircle = circle\n        }\n      }\n      selectedCircleOffset = {\n        x: selectedCircleOffset.x + event.movementX,\n        y: selectedCircleOffset.y + event.movementY,\n      }\n      updateCircleOffsets()\n    }\n  })\n\n  window.addEventListener('pointerup', function () {\n    if (isSelectingCircles()) {\n      if (selectedCircles.size >= 2) {\n        if (hasSquareBeenSelected(selectedCircles, numberOfColumns)) {\n          const circles = circleGrid.querySelectorAll('.circle')\n          for (const circle of circles) {\n            if (determineCircleColor(circle) === selectedColor) {\n              removeCircle(circle)\n            }\n          }\n        } else {\n          selectedCircles.forEach(removeCircle)\n        }\n      }\n\n      if (lastCircleThatTheSelectedCircleWasMovingTowards) {\n        const { x: offsetX, y: offsetY } = determineSelectedCircleOffset()\n        const distanceMoved = Math.abs(offsetX + offsetY)\n        if (distanceMoved > DISTANCE_THRESHOLD) {\n          swapCircles(firstSelectedCircle, lastCircleThatTheSelectedCircleWasMovingTowards)\n\n          let circlesToRemove = new Set()\n          for (const circle of new Set([firstSelectedCircle, lastCircleThatTheSelectedCircleWasMovingTowards])) {\n            let circlesToRemovePart = new Set()\n            const color = determineCircleColor(circle)\n            const startPosition = determinePosition(circle)\n            const horizontalOffsets = new Set([\n              { row: 0, column: -1 },\n              { row: 0, column: 1 },\n            ])\n            const verticalOffsets = new Set([\n              { row: -1, column: 0 },\n              { row: 1, column: 0 },\n            ])\n            const offsetSets = new Set([horizontalOffsets, verticalOffsets])\n            for (const offsetSet of offsetSets) {\n              let circlesWithSameColor = new Set()\n              for (const offset of offsetSet) {\n                circlesWithSameColor = union(\n                  circlesWithSameColor,\n                  determineCirclesWithSameColorInDirection(color, startPosition, offset)\n                )\n              }\n              if (circlesWithSameColor.size >= MINIMUM_AMOUNT_OF_CIRCLES_ON_SAME_LINE_FOR_REMOVAL - 1) {\n                circlesToRemovePart = union(circlesToRemovePart, circlesWithSameColor)\n              }\n            }\n            if (circlesToRemovePart.size >= 1) {\n              circlesToRemovePart.add(circle)\n            }\n            circlesToRemove = union(circlesToRemove, circlesToRemovePart)\n          }\n\n          removeCircles(circlesToRemove)\n        }\n      }\n\n      firstSelectedCircle.classList.remove('circle--dragged')\n      removeSelectedCircleOffset()\n      removeLastCircleThatTheSelectedCircleWasMovingTowardsOffset()\n\n      selectedCircles = new Set()\n      firstSelectedCircle = null\n      selectedColor = null\n      lastSelectedCircle = null\n      selectedCircleOffset = null\n      lastCircleThatTheSelectedCircleWasMovingTowards = null\n      context.clearRect(0, 0, connectionLineCanvas.width, connectionLineCanvas.height)\n    }\n  })\n\n  function updateCircleOffsets() {\n    updateSelectedCircleOffset()\n    updateCircleOffsetThatTheSelectedCircleIsMovingTowards()\n  }\n\n  function updateSelectedCircleOffset() {\n    const { x: translateX, y: translateY } = determineSelectedCircleOffset()\n    firstSelectedCircle.style.transform = `translate(${translateX}px, ${translateY}px)`\n  }\n\n  function determineSelectedCircleOffset() {\n    return determineNormalizedCircleOffset(selectedCircleOffset)\n  }\n\n  function determineNormalizedCircleOffset(offset) {\n    const { x, y } = offset\n    const absoluteX = Math.abs(x)\n    const absoluteY = Math.abs(y)\n    const normalizedX = absoluteX > absoluteY ? Math.sign(x) * Math.min(Math.abs(x), MAXIMUM_MOVE_DISTANCE) : 0\n    const normalizedY = absoluteY > absoluteX ? Math.sign(y) * Math.min(Math.abs(y), MAXIMUM_MOVE_DISTANCE) : 0\n    return {\n      x: normalizedX,\n      y: normalizedY,\n    }\n  }\n\n  function updateCircleOffsetThatTheSelectedCircleIsMovingTowards() {\n    const circle = retrieveCircleThatTheSelectedCircleIsMovingTowards()\n    if (lastCircleThatTheSelectedCircleWasMovingTowards && circle !== lastCircleThatTheSelectedCircleWasMovingTowards) {\n      removeLastCircleThatTheSelectedCircleWasMovingTowardsOffset()\n    }\n    if (circle) {\n      const selectedCircleOffset = determineSelectedCircleOffset()\n      const translateX = -selectedCircleOffset.x\n      const translateY = -selectedCircleOffset.y\n      circle.style.transform = `translate(${translateX}px, ${translateY}px)`\n    }\n    lastCircleThatTheSelectedCircleWasMovingTowards = circle\n  }\n\n  function retrieveCircleThatTheSelectedCircleIsMovingTowards() {\n    const { x, y } = selectedCircleOffset\n    if (x !== 0 || y !== 0) {\n      const absoluteX = Math.abs(x)\n      const absoluteY = Math.abs(y)\n      const rowOffset = absoluteY > absoluteX ? (y > 0 ? 1 : -1) : 0\n      const columnOffset = absoluteX > absoluteY ? (x > 0 ? 1 : -1) : 0\n      const offset = {\n        row: rowOffset,\n        column: columnOffset,\n      }\n      const circle = retrieveCircleWithOffsetToOtherCircle(firstSelectedCircle, offset)\n      return circle\n    } else {\n      return null\n    }\n  }\n\n  function removeSelectedCircleOffset() {\n    removeCircleOffset(firstSelectedCircle)\n  }\n\n  function removeLastCircleThatTheSelectedCircleWasMovingTowardsOffset() {\n    if (lastCircleThatTheSelectedCircleWasMovingTowards) {\n      removeCircleOffset(lastCircleThatTheSelectedCircleWasMovingTowards)\n    }\n  }\n\n  function removeCircleOffset(circle) {\n    circle.style.transform = null\n  }\n\n  function removeCircles(circles) {\n    for (const circle of circles) {\n      circle.style.visibility = 'hidden'\n\n      const column = circle.parentElement\n      const newCircle = createCircleWithRandomColor(colors)\n      column.appendChild(newCircle)\n    }\n    const columns = groupCirclesIntoColumns(circles)\n    const maximumFallOffset =\n      Math.max(...Array.from(columns).map(column => column.size)) *\n      (CIRCLE_HEIGHT + 2 * CIRCLE_BORDER + SPACE_BETWEEN_CIRCLES)\n    circleGrid.style.top = `${-maximumFallOffset}px`\n    for (let index = 0; index < columns.length; index++) {\n      const column = columns[index]\n      if (column.size >= 1) {\n        animateCircleFallInColumn(index, column)\n      }\n    }\n    const onTransitionEnd = debounce(function () {\n      circleGrid.style.top = '0px'\n      circleGrid.removeEventListener('transitionend', onTransitionEnd)\n    })\n    circleGrid.addEventListener('transitionend', onTransitionEnd)\n  }\n\n  function animateCircleFallInColumn(column, circlesThatAreRemovedInColumn) {\n    const circlesThatFallInColumn = determineCirclesThatFallInColumn(column, circlesThatAreRemovedInColumn)\n\n    for (const circleThatFallsInColumn of circlesThatFallInColumn) {\n      circleThatFallsInColumn.classList.add('circle--falling')\n    }\n\n    const fallOffset = circlesThatAreRemovedInColumn.size * (CIRCLE_HEIGHT + 2 * CIRCLE_BORDER + SPACE_BETWEEN_CIRCLES)\n    requestAnimationFrame(() => {\n      for (const circleThatFallsInColumn of circlesThatFallInColumn) {\n        circleThatFallsInColumn.style.top = `${fallOffset}px`\n      }\n\n      const onTransitionEnd = debounce(function () {\n        for (const circle of circlesThatAreRemovedInColumn) {\n          circle.remove()\n        }\n        for (const circleThatFallsInColumn of circlesThatFallInColumn) {\n          circleThatFallsInColumn.classList.remove('circle--falling')\n        }\n        circleGrid.removeEventListener('transitionend', onTransitionEnd)\n      })\n      circleGrid.addEventListener('transitionend', onTransitionEnd)\n    })\n  }\n\n  function groupCirclesIntoColumns(circles) {\n    const columns = new Array(numberOfColumns)\n    for (let index = 0; index < columns.length; index++) {\n      columns[index] = new Set()\n    }\n    for (const circle of circles) {\n      const { column } = determinePosition(circle)\n      columns[column].add(circle)\n    }\n    return columns\n  }\n\n  function determineCirclesThatFallInColumn(column, circlesThatAreRemovedInColumn) {\n    const circlesThatFall = new Set()\n    let smallestRowOfCirclesThatFall = Math.min(\n      ...Array.from(circlesThatAreRemovedInColumn).map(circle => determinePosition(circle).row)\n    )\n    let row = 0\n    while (row < smallestRowOfCirclesThatFall) {\n      const circleThatFalls = retrieveCircleAtPosition({\n        row,\n        column,\n      })\n      circlesThatFall.add(circleThatFalls)\n      row++\n    }\n    return circlesThatFall\n  }\n\n  function removeCircle(circle) {\n    const column = circle.parentElement\n    circle.remove()\n    const newCircle = createCircleWithRandomColor(colors)\n    column.appendChild(newCircle)\n  }\n\n  function drawConnectionLine(circleA, circleB) {\n    context.beginPath()\n    const { x: x1, y: y1 } = calculateElementCenter(circleA)\n    context.moveTo(x1, y1)\n    const { x: x2, y: y2 } = calculateElementCenter(circleB)\n    context.lineTo(x2, y2)\n    context.stroke()\n  }\n\n  function retrieveCircleWithOffsetToOtherCircle(otherCircle, offset) {\n    const otherCirclePosition = determinePosition(otherCircle)\n    const circlePosition = {\n      row: otherCirclePosition.row + offset.row,\n      column: otherCirclePosition.column + offset.column,\n    }\n    const circle = retrieveCircleAtPosition(circlePosition)\n    return circle\n  }\n\n  function retrieveCircleAtPosition(position) {\n    const { row, column } = position\n    if (row < numberOfRows && column < numberOfColumns) {\n      const allCirclesColumns = circleGrid.querySelectorAll('.circles-column')\n      const circlesColumn = allCirclesColumns[column]\n      const circlesInColumn = circlesColumn.children\n      const circle = circlesInColumn[circlesInColumn.length - 1 - row]\n      return circle\n    } else {\n      return null\n    }\n  }\n\n  function swapCircles(circleA, circleB) {\n    const circleAColorClass = determineCircleColorClass(circleA)\n    const circleBColorClass = determineCircleColorClass(circleB)\n    circleA.classList.remove(circleAColorClass)\n    circleB.classList.remove(circleBColorClass)\n    circleA.classList.add(circleBColorClass)\n    circleB.classList.add(circleAColorClass)\n  }\n\n  function determineCirclesWithSameColorInDirection(color, startPosition, offset) {\n    const circles = new Set()\n    let position = determinePositionRelativeTo(startPosition, offset)\n    while (position.row < numberOfRows && position.column < numberOfColumns) {\n      const circle = retrieveCircleAtPosition(position)\n      const hasCircleSameColor = determineCircleColor(circle) === color\n      if (hasCircleSameColor) {\n        circles.add(circle)\n      } else {\n        break\n      }\n\n      position = determinePositionRelativeTo(position, offset)\n    }\n\n    return circles\n  }\n\n  function spawnCircles(element, { rows, columns, colors }) {\n    for (let column = 0; column < columns; column++) {\n      const $column = document.createElement('div')\n      $column.classList.add('circles-column')\n      element.appendChild($column)\n\n      for (let row = 0; row < rows; row++) {\n        const colorCandidates = new Set(colors)\n        if (column >= 2) {\n          const circlesToTheLeft = [\n            retrieveCircleAtPosition({\n              row: numberOfRows - 1 - row,\n              column: column - 1,\n            }),\n            retrieveCircleAtPosition({\n              row: numberOfRows - 1 - row,\n              column: column - 2,\n            }),\n          ]\n          if (areAllEqual(circlesToTheLeft.map(circle => determineCircleColor(circle)))) {\n            const color = determineCircleColor(circlesToTheLeft[0])\n            colorCandidates.delete(color)\n          }\n        }\n        if (row >= 2) {\n          const circlesBelow = [\n            $column.children[$column.children.length - 1],\n            $column.children[$column.children.length - 2],\n          ]\n          if (areAllEqual(circlesBelow.map(circle => determineCircleColor(circle)))) {\n            const color = determineCircleColor(circlesBelow[0])\n            colorCandidates.delete(color)\n          }\n        }\n        const circle = createCircleWithRandomColor(Array.from(colorCandidates))\n        $column.appendChild(circle)\n      }\n    }\n  }\n}\n\nfunction canBeConnected(circleA, circleB) {\n  const positionA = determinePosition(circleA)\n  const positionB = determinePosition(circleB)\n  const rowDifference = Math.abs(positionA.row - positionB.row)\n  const columnDifference = Math.abs(positionA.column - positionB.column)\n  return (rowDifference === 0 && columnDifference === 1) || (columnDifference === 0 && rowDifference === 1)\n}\n\nfunction determinePosition(circle) {\n  return {\n    row: (circle.offsetTop - CIRCLE_MARGIN) / (CIRCLE_BORDER + CIRCLE_HEIGHT + CIRCLE_BORDER + SPACE_BETWEEN_CIRCLES),\n    column:\n      (circle.offsetLeft - CIRCLE_MARGIN) / (CIRCLE_BORDER + CIRCLE_WIDTH + CIRCLE_BORDER + SPACE_BETWEEN_CIRCLES),\n  }\n}\n\nfunction determinePositionRelativeTo(position, offset) {\n  return {\n    row: position.row + offset.row,\n    column: position.column + offset.column,\n  }\n}\n\nfunction determineCircleColor(circle) {\n  return extractColorName(determineCircleColorClass(circle))\n}\n\nfunction determineCircleColorClass(circle) {\n  return Array.from(circle.classList).find(className => className.includes('--'))\n}\n\nfunction extractColorName(colorClass) {\n  return colorClass.split('--')[1]\n}\n\nfunction hasSquareBeenSelected(selectedCircles, numberOfColumns) {\n  if (selectedCircles.size === 4) {\n    const positions = Array.from(selectedCircles).map(determinePosition)\n    positions.sort((a, b) => calculateIndex(a, numberOfColumns) - calculateIndex(b, numberOfColumns))\n    return (\n      positions[0].row === positions[1].row &&\n      positions[0].column === positions[1].column - 1 &&\n      positions[2].row === positions[3].row &&\n      positions[2].column === positions[3].column - 1 &&\n      positions[0].row === positions[2].row - 1\n    )\n  } else {\n    return false\n  }\n}\n\nfunction calculateIndex(position, numberOfColumns) {\n  return position.row * numberOfColumns + position.column\n}\n\nfunction calculateElementCenter(element) {\n  return {\n    x: element.offsetLeft + 0.5 * element.clientWidth,\n    y: element.offsetTop + 0.5 * element.clientHeight,\n  }\n}\n\nfunction areAllEqual(elements) {\n  return new Set(elements).size === 1\n}\n\nfunction createCircleWithRandomColor(colors) {\n  const color = generateRandomColor(colors)\n  const circle = createCircle({ color })\n  return circle\n}\n\nfunction createCircle({ color }) {\n  const circle = document.createElement('div')\n  circle.classList.add('circle')\n  circle.classList.add(`circle--${color}`)\n  return circle\n}\n\nfunction generateRandomColor(colors) {\n  return selectRandomUniform(colors)\n}\n\nfunction union(...sets) {\n  const unionSet = new Set()\n\n  for (const set of sets) {\n    for (const value of set) {\n      unionSet.add(value)\n    }\n  }\n\n  return unionSet\n}\n","import { randomInteger } from './randomInteger.js'\n\nexport function selectRandomUniform(values) {\n  return values[randomInteger(0, values.length - 1)]\n}\n","export function randomInteger(minInclusive, maxInclusive) {\n  minInclusive = Math.floor(minInclusive)\n  maxInclusive = Math.floor(maxInclusive)\n  return minInclusive + Math.floor(Math.random() * (maxInclusive - minInclusive + 1))\n}\n"],"names":["reTrim","reIsBadHex","reIsBinary","reIsOctal","freeParseInt","parseInt","freeGlobal","g","Object","freeSelf","self","root","Function","objectToString","prototype","toString","nativeMax","Math","max","nativeMin","min","now","Date","isObject","value","type","toNumber","isObjectLike","call","isSymbol","other","valueOf","replace","isBinary","test","slice","module","exports","func","wait","options","lastArgs","lastThis","maxWait","result","timerId","lastCallTime","lastInvokeTime","leading","maxing","trailing","TypeError","invokeFunc","time","args","thisArg","undefined","apply","leadingEdge","setTimeout","timerExpired","shouldInvoke","timeSinceLastCall","trailingEdge","remainingWait","debounced","isInvoking","arguments","this","cancel","clearTimeout","flush","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","defineProperty","enumerable","get","globalThis","e","window","obj","prop","hasOwnProperty","main","colors","circleGrid","document","querySelector","element","rows","columns","column","$column","createElement","classList","add","appendChild","row","colorCandidates","Set","circlesToTheLeft","retrieveCircleAtPosition","numberOfRows","areAllEqual","map","circle","determineCircleColor","color","delete","circlesBelow","children","length","createCircleWithRandomColor","Array","from","spawnCircles","connectionLineCanvas","width","clientWidth","height","clientHeight","context","getContext","selectedCircles","firstSelectedCircle","selectedColor","lastSelectedCircle","selectedCircleOffset","lastCircleThatTheSelectedCircleWasMovingTowards","isSelectingCircles","updateCircleOffsets","x","translateX","y","translateY","determineSelectedCircleOffset","style","transform","updateSelectedCircleOffset","absoluteX","abs","absoluteY","otherCircle","offset","otherCirclePosition","determinePosition","retrieveCircleWithOffsetToOtherCircle","retrieveCircleThatTheSelectedCircleIsMovingTowards","removeLastCircleThatTheSelectedCircleWasMovingTowardsOffset","updateCircleOffsetThatTheSelectedCircleIsMovingTowards","sign","CIRCLE_LENGTH","determineNormalizedCircleOffset","removeCircleOffset","animateCircleFallInColumn","circlesThatAreRemovedInColumn","circlesThatFallInColumn","circlesThatFall","smallestRowOfCirclesThatFall","circleThatFalls","determineCirclesThatFallInColumn","circleThatFallsInColumn","fallOffset","size","requestAnimationFrame","top","onTransitionEnd","debounce","remove","removeEventListener","addEventListener","removeCircle","parentElement","newCircle","position","circlesInColumn","querySelectorAll","determineCirclesWithSameColorInDirection","startPosition","circles","determinePositionRelativeTo","event","target","contains","preventDefault","has","circleA","circleB","positionA","positionB","rowDifference","columnDifference","canBeConnected","beginPath","x1","y1","calculateElementCenter","moveTo","x2","y2","lineTo","stroke","drawConnectionLine","movementX","movementY","numberOfColumns","positions","sort","b","calculateIndex","hasSquareBeenSelected","forEach","offsetX","offsetY","circleAColorClass","determineCircleColorClass","circleBColorClass","swapCircles","circlesToRemove","circlesToRemovePart","horizontalOffsets","verticalOffsets","offsetSets","offsetSet","circlesWithSameColor","union","MINIMUM_AMOUNT_OF_CIRCLES_ON_SAME_LINE_FOR_REMOVAL","visibility","index","groupCirclesIntoColumns","maximumFallOffset","removeCircles","clearRect","offsetTop","offsetLeft","split","find","className","includes","elements","values","minInclusive","maxInclusive","floor","random","generateRandomColor","createCircle","sets","unionSet","set"],"sourceRoot":""}